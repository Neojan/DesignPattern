#include <iostream>
#include <string>

using namespace std;

// 五种关系的耦合强弱比较：依赖<关联<聚合<组合<继承
// 继承
// 实线+空心箭头 一一▷
// 可描述为：Is a
// 泛化也称继承，子类将继承父类的所有属性和方法，并且可以根据需要对父类进行拓展。

// 3、为什么要多用组合少用继承？
// 继承和组合各 有优缺点。
// 类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。
//对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。由于组合要求对象具有良好定义的接口，而且，对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。

// Goose继承自Animal
class Animal {
public:
    Animal() {}
    ~Animal() {}
};

// 实现
// 虚线+空心箭头 ----▷
// 箭头由Goose指向fly

class Goose : public Animal {
public:
    Goose() {}
    ~Goose() {}
    void fly()
    {
        // interface
    }
};
